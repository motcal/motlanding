<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mesh Optical Technologies</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: black;
      color: white;
      font-family: monospace;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100vh; /* Ensures everything fits in one screen */
      text-align: center;
      overflow: hidden; /* Avoid scrollbars during animation */
    }
    .header {
      max-width: 70%;
      font-size: 0.5rem;
      font-weight: bold;
      margin-bottom: 30px;
      z-index: 10;
      background-color: black;
    }
    .content {
      max-width: 70%;
      font-size: 1.0rem; /* Default text size */
      line-height: 1.6;
      z-index: 10;
      background-color: black;
    }
    @media (max-width: 1000px) {
      .header {
        font-size: .28rem; /* Slightly smaller header on mobile */
      }
      .content {
        font-size: 1.1rem; /* Bigger text for readability */
      }
    }
    /* Laser styling */
    .laser {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1; /* Behind header/content */
      color: white;
      white-space: nowrap; /* Keep text in one line */
      transform-origin: left center; /* Rotate around the left edge for convenience */
    }
  </style>
</head>
<body>

  <!-- Header Text -->
  <div class="header" id="header">
    <pre>

░▒▓██████████████▓▒░░▒▓████████▓▒░░▒▓███████▓▒░▒▓█▓▒░░▒▓█▓▒░       ░▒▓██████▓▒░░▒▓███████▓▒░▒▓████████▓▒░▒▓█▓▒░░▒▓██████▓▒░ ░▒▓██████▓▒░░▒▓█▓▒░        
░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░   ░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░        
░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░   ░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░        
░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓██████▓▒░  ░▒▓██████▓▒░░▒▓████████▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓███████▓▒░  ░▒▓█▓▒░   ░▒▓█▓▒░▒▓█▓▒░      ░▒▓████████▓▒░▒▓█▓▒░        
░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░             ░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░        ░▒▓█▓▒░   ░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░        
░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░             ░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░        ░▒▓█▓▒░   ░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░        
░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓████████▓▒░▒▓███████▓▒░░▒▓█▓▒░░▒▓█▓▒░       ░▒▓██████▓▒░░▒▓█▓▒░        ░▒▓█▓▒░   ░▒▓█▓▒░░▒▓██████▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓████████▓▒░ 
                                                                                                                                                       
                                                                                                                                                       
░▒▓████████▓▒░▒▓████████▓▒░▒▓██████▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓███████▓▒░ ░▒▓██████▓▒░░▒▓█▓▒░      ░▒▓██████▓▒░ ░▒▓██████▓▒░░▒▓█▓▒░▒▓████████▓▒░░▒▓███████▓▒░   
   ░▒▓█▓▒░   ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░          
   ░▒▓█▓▒░   ░▒▓█▓▒░     ░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░          
   ░▒▓█▓▒░   ░▒▓██████▓▒░░▒▓█▓▒░      ░▒▓████████▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒▒▓███▓▒░▒▓█▓▒░▒▓██████▓▒░  ░▒▓██████▓▒░    
   ░▒▓█▓▒░   ░▒▓█▓▒░     ░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░             ░▒▓█▓▒░   
   ░▒▓█▓▒░   ░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░     ░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░▒▓█▓▒░             ░▒▓█▓▒░   
   ░▒▓█▓▒░   ░▒▓████████▓▒░▒▓██████▓▒░░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓██████▓▒░░▒▓████████▓▒░▒▓██████▓▒░ ░▒▓██████▓▒░░▒▓█▓▒░▒▓████████▓▒░▒▓███████▓▒░    
                                                                                                                                                                                                                                                                                            
    </pre>
  </div>

  <!-- Centered Body Text -->
  <div class="content" id="content">
    Mesh optical technologies designs and manufactures the world's most advanced optical computing hardware.
    We believe that mastery of the photon is fundamental to humanity's technological advancement.<br><br>

    Our team designing each product to the limit of physics and builds the machines that make them.
    We are looking for bright engineers who are interested in helping us build the future of photonics
    manufactuing in America.<br><br>

    If you are interested in helping us build our first factory in Los Angeles, please send your resume to
    join at meshoptical dot com.
  </div>

  <script>
    /********************************************************
     * Configuration
     ********************************************************/
    const numBeams = 5;            // Number of laser beams
    const speed = 2;               // Pixels per animation frame
    const normalLaserText = "--------";  // Normal laser trail
    const diffractionPatterns = [
      "/ / / / / /",
      "\\ \\ \\ \\ \\ \\",
      "| | | | | |",
      "/\\/\\/\\/\\/\\"
    ];
    const diffractionDuration = 800; // ms: how long the diffraction pattern is shown

    /********************************************************
     * Globals & Initialization
     ********************************************************/
    let width = window.innerWidth;
    let height = window.innerHeight;

    const headerEl = document.getElementById("header");
    const contentEl = document.getElementById("content");

    // Update screen dimensions on resize
    window.addEventListener("resize", () => {
      width  = window.innerWidth;
      height = window.innerHeight;
    });

    // Keep track of all beams in an array
    const beams = [];

    // Create the beams
    for (let i = 0; i < numBeams; i++) {
      beams.push(createBeam());
    }

    // Start the animation loop
    requestAnimationFrame(animate);

    /********************************************************
     * Beam creation & helper functions
     ********************************************************/
    function createBeam() {
      // 1) Randomly pick one of the four edges
      const edge = Math.floor(Math.random() * 4);
      // 2) Random angle in the correct range for that edge
      const angleDeg = randomAngleForEdge(edge);

      // 3) Convert angle to radians
      const angleRad = angleDeg * (Math.PI / 180);

      // 4) Create DOM element for the beam
      const laserEl = document.createElement("div");
      laserEl.className = "laser";
      laserEl.textContent = normalLaserText;
      document.body.appendChild(laserEl);

      // 5) Position the beam at that edge
      let x = 0, y = 0;
      switch (edge) {
        case 0: // top
          x = Math.random() * (width - 50);
          y = 0;
          break;
        case 1: // right
          x = width;
          y = Math.random() * (height - 50);
          break;
        case 2: // bottom
          x = Math.random() * (width - 50);
          y = height;
          break;
        case 3: // left
          x = 0;
          y = Math.random() * (height - 50);
          break;
      }

      // 6) Compute velocity from angle + speed
      let dx = speed * Math.cos(angleRad);
      let dy = speed * Math.sin(angleRad);

      // Return the beam object
      return {
        element: laserEl,
        x, y,        // current position
        dx, dy,      // velocity
        angleDeg,
        diffractionTimeout: null
      };
    }

    // Returns a random angle (in degrees) that keeps the beam traveling inward
    // at an angle between 30°..150°, etc., depending on the edge.
    function randomAngleForEdge(edge) {
      // We'll define these angle ranges so the beam always travels inward:
      // top    => [30..150]   (downward-ish)
      // right  => [120..240]  (leftward-ish)
      // bottom => [210..330]  (upward-ish)
      // left   => [300..360) U [0..60] (rightward-ish)
      switch (edge) {
        case 0: // top
          return randomRange(30, 150);
        case 1: // right
          return randomRange(120, 240);
        case 2: // bottom
          return randomRange(210, 330);
        case 3: // left
          // We'll pick from 300..420, then mod by 360,
          // effectively [300..360) U [0..60)
          return (randomRange(300, 420) % 360);
      }
    }

    // Return random number in [min, max].
    function randomRange(min, max) {
      return Math.random() * (max - min) + min;
    }

    /********************************************************
     * Main animation loop
     ********************************************************/
    function animate() {
      // Update each beam
      for (let beam of beams) {
        updateBeam(beam);
      }
      requestAnimationFrame(animate);
    }

    /********************************************************
     * Beam Update (position, bounce, diffraction)
     ********************************************************/
    function updateBeam(beam) {
      // 1) Move
      beam.x += beam.dx;
      beam.y += beam.dy;

      // 2) Bounce off screen edges (simple bounding)
      const el = beam.element;
      const beamWidth = el.offsetWidth;
      const beamHeight = el.offsetHeight;

      let collided = false;

      // Left/right edges
      if (beam.x <= 0) {
        beam.x = 0;
        beam.dx = -beam.dx;
        collided = true;
      } else if (beam.x + beamWidth >= width) {
        beam.x = width - beamWidth;
        beam.dx = -beam.dx;
        collided = true;
      }

      // Top/bottom edges
      if (beam.y <= 0) {
        beam.y = 0;
        beam.dy = -beam.dy;
        collided = true;
      } else if (beam.y + beamHeight >= height) {
        beam.y = height - beamHeight;
        beam.dy = -beam.dy;
        collided = true;
      }

      // 3) Check collisions with the header & content
      // Get bounding boxes for the header and content
    //   const headerRect = headerEl.getBoundingClientRect();
    //   const contentRect = contentEl.getBoundingClientRect();

    //   // Attempt bounce with each of those
    //   if (bounceOffElement(beam, beamWidth, beamHeight, headerRect)) {
    //     collided = true;
    //   }
    //   if (bounceOffElement(beam, beamWidth, beamHeight, contentRect)) {
    //     collided = true;
    //   }

      // If any collision occurred, trigger diffraction
      if (collided) {
        triggerDiffraction(beam);
      }

      // 4) Update the rotation so the beam looks correct
      const angleRad = Math.atan2(beam.dy, beam.dx);
      const angleDeg = angleRad * (180 / Math.PI);
      el.style.transform = `translate(${beam.x}px, ${beam.y}px) rotate(${angleDeg}deg)`;
    }

    /********************************************************
     * bounceOffElement
     * Checks if the beam's bounding box intersects 'elementRect'.
     * If so, we compute which side was hit and invert dx or dy.
     ********************************************************/
    function bounceOffElement(beam, beamWidth, beamHeight, elementRect) {
      // Convert elementRect (DOMRect) to simpler coords
      const rectLeft   = elementRect.left;
      const rectRight  = elementRect.right;
      const rectTop    = elementRect.top;
      const rectBottom = elementRect.bottom;

      // Beam's bounding box
      const beamLeft   = beam.x;
      const beamRight  = beam.x + beamWidth;
      const beamTop    = beam.y;
      const beamBottom = beam.y + beamHeight;

      // Check for intersection (no intersection if any side is out of range)
      if (
        beamRight  < rectLeft   ||
        beamLeft   > rectRight  ||
        beamBottom < rectTop    ||
        beamTop    > rectBottom
      ) {
        // No collision
        return false;
      }

      // We have overlap. Determine how much we overlap on each side.
      const overlapLeft   = beamRight  - rectLeft;   // Overlap from left side of rect
      const overlapRight  = rectRight  - beamLeft;   // Overlap from right side
      const overlapTop    = beamBottom - rectTop;    // Overlap from top side
      const overlapBottom = rectBottom - beamTop;    // Overlap from bottom side

      // The collision side is the one with the smallest overlap
      const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

      if (minOverlap === overlapLeft) {
        // Beam hit the rectangle’s left edge
        beam.x -= overlapLeft; // Push it back
        beam.dx = -beam.dx;    // Reflect horizontally
      } else if (minOverlap === overlapRight) {
        // Beam hit the rectangle’s right edge
        beam.x += overlapRight;
        beam.dx = -beam.dx;
      } else if (minOverlap === overlapTop) {
        // Beam hit the top edge
        beam.y -= overlapTop;
        beam.dy = -beam.dy;
      } else {
        // Beam hit the bottom edge
        beam.y += overlapBottom;
        beam.dy = -beam.dy;
      }

      return true; // We had a collision
    }

    /********************************************************
     * Diffraction Effect
     ********************************************************/
    function triggerDiffraction(beam) {
      // If it's already diffracting, don't interrupt
      if (beam.element.textContent !== normalLaserText) return;

      const randomPattern = diffractionPatterns[
        Math.floor(Math.random() * diffractionPatterns.length)
      ];
      beam.element.textContent = randomPattern;

      // Clear any existing timeout
      if (beam.diffractionTimeout) {
        clearTimeout(beam.diffractionTimeout);
      }

      // After diffractionDuration ms, revert to normal
      beam.diffractionTimeout = setTimeout(() => {
        beam.element.textContent = normalLaserText;
        beam.diffractionTimeout = null;
      }, diffractionDuration);
    }

</script>

</body>
</html>
